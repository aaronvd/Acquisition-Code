import gclib
import time

def stage_start(address): # initialize connection
    g = gclib.py()
    g.GOpen(address)
    # print(g.GInfo())
    # query controller model number with g.GCommand(char(18) + '' + char(22))
    # print(g.GCommand('MG_BN')) # query for serial number
    return g

def stop_stage(g): # stop the stage
    g.GCommand('ST')

def zero_axes(g): # zero the x,y axes
    defZeroInXsteps = float(g.GCommand('MG _RPA'))
    defZeroInYsteps = float(g.GCommand('MG _RPB'))

    return defZeroInXsteps, defZeroInYsteps

def get_position(g,defZeroInXsteps,defZeroInYsteps): # get current position
    steptomm = 5000
    xposSteps = float(g.GCommand('MG _RPA'))
    yposSteps = float(g.GCommand('MG _RPB'))
    
    # note negative sign to match NFS coord Sys
    xUserPos = -(xposSteps-defZeroInXsteps)/steptomm 
    yUserPos = -(yposSteps-defZeroInYsteps)/steptomm

    return xUserPos, yUserPos

def get_step_position(g): # get current position in steps
    # steptomm = 5000. initialized in MATLAB code but never used TODO
    xposSteps = float(g.GCommand('MG _RPA'))
    yposSteps = float(g.GCommand('MG _RPB'))

    return xposSteps, yposSteps

def range_of_stage(g, speedmms):
    steptomm = 5000  # conversion factor from steps to mm
    stepperspeed = round(speedmms*steptomm)  # speed in cts/sec
    stepperaccel = round(10*stepperspeed)  # acceleration in cts/sec^2

    stagerangetest = (
        # jog until you hit limits
        'AC {},{};'.format(stepperaccel, stepperaccel) + # set accelerations of motors A,B
        'DC {},{};'.format(stepperaccel, stepperaccel) + # set decelerations of A,B
        'JG {},{};'.format(-stepperspeed, -stepperspeed) + # set jog speeds and directions
        'BG;' +  # start motion
        'AM;' +  # after motion is complete

        'PR 5000,5000;' +  # move 0.5mm step back from edge
        'BG;' +  # begin motion
        
        # after motion, capture min step values
        'AM;' + 
        'minx=_RPA;' +
        'miny=_RPB;' +

        # jog to other side and record pos
        'JG {},{};'.format(stepperspeed, stepperspeed) + # set jog speeds and directions
        'BG;' +  # begin motion

        # after motion, capture max step values
        'AM;' +
        'maxx=_RPA;' +
        'maxy=_RPB;' +

        # find range in steps
        'rangex=maxx-minx;' + 
        'rangey=maxy-miny;' +
        'AM;'+

        # restore standard stage speed, accel, decel
        'SP 125000,125000;' +
        'AC 1250000,1250000;' +
        'DC 1250000,1250000;' +

        # center stage (?)
        'PR -5000,-5000;' +
        'BG;' +

        # after motion, end program
        'AM;' + 
        'EN;'
    )

    # download and execute the program
    g.GProgramDownload(stagerangetest, '')
    g.GCommand('XQ')

    # wait until test is done (?)
    testdone = 1
    while(testdone > -1 or is_nan(testdone)):
        time.sleep(.01)
        testdone = float(g.GCommand('MG _XQ'))

    # get values of rangex,rangey in mm
    xrange = float(g.GCommand('MG rangex'))/steptomm
    yrange = float(g.GCommand('MG rangey'))/steptomm

    # add save to file feature (?)
    #
    #

    return xrange, yrange

def stage_home(g,speedmms):
    steptomm = 5000  # conversion factor from steps to mm
    stepperspeed = round(speedmms*steptomm)  # speed in cts/sec
    stepperaccel = round(10*stepperspeed)  # acceleration in cts/sec^2
    
    stagehome = (
        # set acceleration, deceleration of motors A,B
        'AC {},{};'.format(stepperaccel, stepperaccel) +
        'DC {},{};'.format(stepperaccel, stepperaccel) +

        # jog until you hit limits
        'JG {},{};'.format(-stepperspeed, -stepperspeed) + # set jog speeds and directions
        'BG;' +

        # after motion, move 1mm step back from edge
        'AM;'+ 
        'PR 10000,10000;' + 
        'BG;' +

        # after motion, define current positions of A,B as 0,0
        'AM;' + 
        'DP 0,0;' + 

        # capture min x,y step values
        'minx=_RPA;' + # _RPa is the "commanded position generated by the profiler for the 'a' axis"
        'miny=_RPB;' +  # _RPb is the "commanded position generated by the profiler for the 'b' axis"

        # set slew speeds of A,B and end program
        'SP 125000,125000;' +
        'EN;'
    ) 

    # download and execute the program
    g.GProgramDownload(stagehome, '')
    g.GCommand('XQ')

    # wait until test is done (?)
    testdone = 1
    while(testdone > -1 or is_nan(testdone)):
        time.sleep(.01)
        testdone = float(g.GCommand('MG _XQ'))
    
    # get values of minx,miny and return
    xminstepVal = float(g.GCommand('MG minx'))
    yminstepVal = float(g.GCommand('MG miny'))
    
    return xminstepVal, yminstepVal

def move_to_relative(g,speedmms,defZeroInXsteps,defZeroInYsteps,moveXmm,moveYmm):
    steptomm = 5000  # conversion factor from steps to mm
    stepperspeed = round(speedmms*steptomm)  # speed in cts/sec
    stepperaccel = round(10*stepperspeed)  # acceleration in cts/sec^2

    stagemove = (
        # set accelerations, decelerations, slew speeds of motors A,B
        'AC {},{};'.format(stepperaccel, stepperaccel) +
        'DC {},{};'.format(stepperaccel, stepperaccel) +
        'SP {},{};'.format(stepperspeed, stepperspeed) +

        # set distances for A,B to move and begin motion
        'PR {},{};'.format(-moveXmm*steptomm,-moveYmm*steptomm) + 
        'BG;' + 

        # after motion, set value of variables posx, posy to _RPa, _RPb
        'AM;' + 
        'posx=_RPA'+ 
        'posy=_RPB' + 

        # end program
        'EN;'
    ) 

    # download and execute the program
    g.GProgramDownload(stagemove, '')
    g.GCommand('XQ')

    # wait until test is done (?)
    testdone = 1
    while(testdone > -1 or is_nan(testdone)):
        time.sleep(.01)
        testdone = float(g.GCommand('MG _XQ'))

    # get values of variables
    xposSteps = float(g.GCommand('MG posx'))
    yposSteps = float(g.GCommand('MG posy'))
    
    # calculate and return current x,y position
    xUserPos = -(xposSteps-defZeroInXsteps)/steptomm
    yUserPos = -(yposSteps-defZeroInYsteps)/steptomm
    
    return xUserPos, yUserPos

def move_to_absolute(g,speedmms,defZeroInXsteps,defZeroInYsteps,moveToUserXmm,moveToUserYmm):
    steptomm = 5000 # conversion factor from steps to mm
    stepperspeed = round(speedmms*steptomm) # speed in cts/sec
    stepperaccel = round(10*stepperspeed) # acceleration in cts/sec^2
    
    stagemove = (
        # set accelerations, decelerations, slew speeds of motors A,B
        'AC {},{};'.format(stepperaccel, stepperaccel) +  # set accelerations of motors A,B
        'DC {},{};'.format(stepperaccel, stepperaccel) + # set decelerations of A,B
        'SP {},{};'.format(stepperspeed, stepperspeed) + # set slew speeds of A,B

        # set desired absolute positions and begin motion
        'PA {},{};'.format(-moveToUserXmm*steptomm+defZeroInXsteps,
                            -moveToUserYmm*steptomm+defZeroInYsteps) +
        'BG;' + 

        # after motion, capture posx,posy values
        'AM;' +
        'posx=_RPA;' +
        'posy=_RPB;' + 

        # end program
        'EN;'
    ) 

    # download and execute the program
    g.GProgramDownload(stagemove, '')
    g.GCommand('XQ')

    # wait until test is done (?)
    testdone = 1
    while(testdone > -1 or is_nan(testdone)):
        time.sleep(.01)
        testdone = float(g.GCommand('MG _XQ'))
    
    # get values of variables posx, posy
    xpos = float(g.GCommand('MG posx'))
    ypos = float(g.GCommand('MG posy'))
    
    # calculate and return current x,y positions
    xUserPos = -(xpos-defZeroInXsteps)/steptomm
    yUserPos = -(ypos-defZeroInYsteps)/steptomm
    
    return xUserPos, yUserPos

def close_connection(g): # close connection with stage
    g.GClose()
    print('Controller connection stopped')

def is_nan(num):
    return num!=num
